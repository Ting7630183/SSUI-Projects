{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nimport App from \"../../App\";\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, selectedObj, oldColor, fillColor, selectedShapeId) {\n    // console.log(\"create a new object\")\n    super(undoHandler, true);\n    this.targetObject = selectedObj;\n    this.newValue = fillColor;\n    this.oldValue = oldColor;\n    this.selectedShapeId = selectedShapeId;\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    if (this.targetObject !== null) {\n      console.log(this.targetObject);\n      console.log(this.oldValue);\n      console.log(this.newValue); // this.targetObject = this.selectedObj; // global variable for selected\n      // this.oldValue = this.selectedObj.fillColor; // object's current color\n      // // this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n      // this.newValue = this.selectedObj.currentColor; // get the color widget's current color\n      // this.targetObject.fillColor = this.newValue; // actually change\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n\n      console.log(\"add to stack\");\n      if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n    }\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    console.log(\"enter undo in the change color class\");\n    console.log(this.oldValue);\n    console.log(this.targetObject);\n    App.updateShape(this.selectedShapeId, this.newValue); // this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    this.targetObject.fillColor = this.newValue; // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {\n    return this.selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {\n    if (this.selectedObj !== null) {\n      this.targetObject = this.selectedObj; // get new selected obj\n\n      this.oldValue = this.selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n\n      this.selectedObj.fillColor = this.newValue; // actually change\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"names":["CommandObject","App","ChangeFillColorCommandObject","constructor","undoHandler","selectedObj","oldColor","fillColor","selectedShapeId","targetObject","newValue","oldValue","execute","console","log","addToUndoStack","registerExecution","undo","updateShape","redo","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AACA,OAAOC,GAAP,MAAgB,WAAhB;AAEA,eAAe,MAAMC,4BAAN,SAA2CF,aAA3C,CAAyD;AACtEG,EAAAA,WAAW,CAACC,WAAD,EAAcC,WAAd,EAA2BC,QAA3B,EAAqCC,SAArC,EAAgDC,eAAhD,EAAiE;AAC1E;AACA,UAAMJ,WAAN,EAAmB,IAAnB;AACA,SAAKK,YAAL,GAAoBJ,WAApB;AACA,SAAKK,QAAL,GAAgBH,SAAhB;AACA,SAAKI,QAAL,GAAgBL,QAAhB;AACA,SAAKE,eAAL,GAAuBA,eAAvB;AACD;AAED;;;;;;AAIAI,EAAAA,OAAO,GAAG;AACR,QAAI,KAAKH,YAAL,KAAsB,IAA1B,EAAgC;AAC9BI,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKL,YAAjB;AACAI,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKH,QAAjB;AACAE,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKJ,QAAjB,EAH8B,CAI9B;AACA;AACA;AACA;AACA;AAEA;AACA;;AACAG,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACA,UAAI,KAAKC,cAAT,EAAyB,KAAKX,WAAL,CAAiBY,iBAAjB,CAAmC,IAAnC;AAC1B;AACF;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACLJ,IAAAA,OAAO,CAACC,GAAR,CAAY,sCAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKH,QAAjB;AACAE,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKL,YAAjB;AACAR,IAAAA,GAAG,CAACiB,WAAJ,CAAgB,KAAKV,eAArB,EAAsC,KAAKE,QAA3C,EAJK,CAKL;AACA;AACD;AAED;;;;;;;AAKAS,EAAAA,IAAI,GAAG;AACL,SAAKV,YAAL,CAAkBF,SAAlB,GAA8B,KAAKG,QAAnC,CADK,CAEL;AACD;AAED;;;;;AAGAU,EAAAA,SAAS,GAAG;AACV,WAAO,KAAKf,WAAL,KAAqB,IAA5B;AACD;AAED;;;;;;AAIAgB,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKhB,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKI,YAAL,GAAoB,KAAKJ,WAAzB,CAD6B,CACS;;AACtC,WAAKM,QAAL,GAAgB,KAAKN,WAAL,CAAiBE,SAAjC,CAF6B,CAEe;AAC5C;;AACA,WAAKF,WAAL,CAAiBE,SAAjB,GAA6B,KAAKG,QAAlC,CAJ6B,CAIe;AAE5C;AACA;;AACA,UAAI,KAAKK,cAAT,EAAyB,KAAKX,WAAL,CAAiBY,iBAAjB,CAAmC,EAAE,GAAG;AAAL,OAAnC;AAC1B;AACF;;AA3EqE","sourcesContent":["import CommandObject from \"./CommandObject\";\nimport App from \"../../App\";\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, selectedObj, oldColor, fillColor, selectedShapeId) {\n    // console.log(\"create a new object\")\n    super(undoHandler, true);\n    this.targetObject = selectedObj;\n    this.newValue = fillColor;\n    this.oldValue = oldColor\n    this.selectedShapeId = selectedShapeId\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    if (this.targetObject !== null) {\n      console.log(this.targetObject)\n      console.log(this.oldValue)\n      console.log(this.newValue)\n      // this.targetObject = this.selectedObj; // global variable for selected\n      // this.oldValue = this.selectedObj.fillColor; // object's current color\n      // // this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n      // this.newValue = this.selectedObj.currentColor; // get the color widget's current color\n      // this.targetObject.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      console.log(\"add to stack\")\n      if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n    }\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    console.log(\"enter undo in the change color class\")\n    console.log(this.oldValue)\n    console.log(this.targetObject)\n    App.updateShape(this.selectedShapeId, this.newValue)\n    // this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    return this.selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    if (this.selectedObj !== null) {\n      this.targetObject = this.selectedObj; // get new selected obj\n      this.oldValue = this.selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n      this.selectedObj.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}