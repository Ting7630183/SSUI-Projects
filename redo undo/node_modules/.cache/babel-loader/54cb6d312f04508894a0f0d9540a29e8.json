{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nexport default class MoveCommandObject extends CommandObject {\n  constructor(undoHandler, orginalMovePosition, newData, selectedShapeId) {\n    super(undoHandler, true);\n    console.log(\"enter move object constructor\");\n    this.origin = orginalMovePosition;\n    console.log(this.origin);\n    this.final = newData;\n    console.log(this.final);\n    this.selectedShapeId = selectedShapeId;\n    this.newData = newData;\n    this.updateShape = undoHandler.updateShape;\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    // let finalCoords = this.final\n    // let initCoords = this.init\n    // var newData = {finalCoords, initCoords}\n    // console.log(newData)\n    this.updateShape(this.selectedShapeId, this.newData);\n    return true;\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    console.log(\"enter move undo\");\n    let orignX = this.origin.x;\n    let orginY = this.origin.y;\n    let finalX = this.final.x;\n    let finalY = this.final.y;\n    let newData = {\n      initCoords: {\n        x: finalX,\n        y: finalY\n      }\n    };\n    console.log(this.selectedShapeId);\n    console.log(newData);\n    this.updateShape(this.selectedShapeId, newData);\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    let finalCoords = this.final;\n    let initCoords = this.init;\n    var newData = {\n      initCoords,\n      finalCoords\n    };\n    console.log(this.selectedShapeId);\n    this.updateShape(this.selectedShapeId, newData);\n  }\n\n  getCurrentSelectedShapeId() {\n    console.log(\"enter get current selected shape id\");\n    return this.selectedShapeId;\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {//   return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {//   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n  }\n\n}","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/MoveCommandObject.js"],"names":["CommandObject","MoveCommandObject","constructor","undoHandler","orginalMovePosition","newData","selectedShapeId","console","log","origin","final","updateShape","execute","undo","orignX","x","orginY","y","finalX","finalY","initCoords","redo","finalCoords","init","getCurrentSelectedShapeId","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AAEA,eAAe,MAAMC,iBAAN,SAAgCD,aAAhC,CAA8C;AACzDE,EAAAA,WAAW,CAACC,WAAD,EAAcC,mBAAd,EAAmCC,OAAnC,EAA4CC,eAA5C,EAA6D;AACtE,UAAMH,WAAN,EAAmB,IAAnB;AACAI,IAAAA,OAAO,CAACC,GAAR,CAAY,+BAAZ;AACA,SAAKC,MAAL,GAAcL,mBAAd;AACAG,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKC,MAAjB;AACA,SAAKC,KAAL,GAAaL,OAAb;AACAE,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKE,KAAjB;AACA,SAAKJ,eAAL,GAAuBA,eAAvB;AACA,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKM,WAAL,GAAmBR,WAAW,CAACQ,WAA/B;AACD;AAED;;;;;;AAKAC,EAAAA,OAAO,GAAG;AACN;AACA;AACA;AACA;AACA,SAAKD,WAAL,CAAiB,KAAKL,eAAtB,EAAuC,KAAKD,OAA5C;AACA,WAAO,IAAP;AACH;AAED;;;;AAEAQ,EAAAA,IAAI,GAAG;AACLN,IAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACE,QAAIM,MAAM,GAAG,KAAKL,MAAL,CAAYM,CAAzB;AACA,QAAIC,MAAM,GAAG,KAAKP,MAAL,CAAYQ,CAAzB;AACA,QAAIC,MAAM,GAAG,KAAKR,KAAL,CAAWK,CAAxB;AACA,QAAII,MAAM,GAAG,KAAKT,KAAL,CAAWO,CAAxB;AACA,QAAIZ,OAAO,GAAG;AAACe,MAAAA,UAAU,EAAE;AAACL,QAAAA,CAAC,EAAEG,MAAJ;AAAYD,QAAAA,CAAC,EAAEE;AAAf;AAAb,KAAd;AACAZ,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKF,eAAjB;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYH,OAAZ;AACA,SAAKM,WAAL,CAAiB,KAAKL,eAAtB,EAAuCD,OAAvC;AACH;AAED;;;;;;;AAKAgB,EAAAA,IAAI,GAAG;AACH,QAAIC,WAAW,GAAG,KAAKZ,KAAvB;AACA,QAAIU,UAAU,GAAG,KAAKG,IAAtB;AACA,QAAIlB,OAAO,GAAG;AAACe,MAAAA,UAAD;AAAaE,MAAAA;AAAb,KAAd;AACAf,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKF,eAAjB;AACA,SAAKK,WAAL,CAAiB,KAAKL,eAAtB,EAAuCD,OAAvC;AACH;;AAEDmB,EAAAA,yBAAyB,GAAE;AACzBjB,IAAAA,OAAO,CAACC,GAAR,CAAY,qCAAZ;AACA,WAAO,KAAKF,eAAZ;AACD;AAED;;;;;AAGAmB,EAAAA,SAAS,GAAG,CACZ;AACC;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG,CACT;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACC;;AAjFwD","sourcesContent":["import CommandObject from \"./CommandObject\";\n\nexport default class MoveCommandObject extends CommandObject {\n    constructor(undoHandler, orginalMovePosition, newData, selectedShapeId) {\n      super(undoHandler, true);\n      console.log(\"enter move object constructor\")\n      this.origin = orginalMovePosition\n      console.log(this.origin)\n      this.final = newData\n      console.log(this.final)\n      this.selectedShapeId = selectedShapeId\n      this.newData = newData\n      this.updateShape = undoHandler.updateShape;\n    }\n  \n    /* override to execute the action of this command.\n     * pass in false for addToUndoStack if this is a command which is NOT\n     * put on the undo stack, like Copy, or a change of selection or Save\n     */\n  \n    execute() {\n        // let finalCoords = this.final\n        // let initCoords = this.init\n        // var newData = {finalCoords, initCoords}\n        // console.log(newData)\n        this.updateShape(this.selectedShapeId, this.newData)\n        return true; \n    }\n  \n    /* override to undo the operation of this command\n     */\n    undo() {\n      console.log(\"enter move undo\")\n        let orignX = this.origin.x\n        let orginY = this.origin.y\n        let finalX = this.final.x\n        let finalY = this.final.y\n        let newData = {initCoords: {x: finalX, y: finalY }, }\n        console.log(this.selectedShapeId)\n        console.log(newData)\n        this.updateShape(this.selectedShapeId, newData)\n    }\n  \n    /* override to redo the operation of this command, which means to\n     * undo the undo. This should ONLY be called if the immediate\n     * previous operation was an Undo of this command. Anything that\n     * can be undone can be redone, so there is no need for a canRedo.\n     */\n    redo() {\n        let finalCoords = this.final\n        let initCoords = this.init\n        var newData = {initCoords, finalCoords}\n        console.log(this.selectedShapeId)\n        this.updateShape(this.selectedShapeId, newData)\n    }\n\n    getCurrentSelectedShapeId(){\n      console.log(\"enter get current selected shape id\")\n      return this.selectedShapeId\n    }\n  \n    /* override to return true if this operation can be repeated in the\n     * current context\n     */\n    canRepeat() {\n    //   return selectedObj !== null;\n    }\n  \n    /* override to execute the operation again, this time possibly on\n     * a new object. Thus, this typically uses the same value but a new\n     * selectedObject.\n     */\n    repeat() {\n    //   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n  \n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n    }\n  }\n\n\n"]},"metadata":{},"sourceType":"module"}