{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler) {\n    super(undoHandler, true);\n\n    this.updateShape = (shapeId, newData) => {\n      let shapesMap = { ...this.state.shapesMap\n      };\n      let targetShape = shapesMap[shapeId];\n      shapesMap[shapeId] = { ...targetShape,\n        ...newData\n      };\n      this.setState({\n        shapesMap\n      });\n    };\n\n    console.log(\"enter change fill color shape constructor\");\n    this.oldValue = undoHandler.oldFillColor;\n    console.log(this.oldValue);\n    this.newValue = undoHandler.currFillColor;\n    console.log(this.newValue);\n    this.targetObject = undoHandler.targetObject;\n    this.updateShape = undoHandler.updateShape;\n    this.selectedShapeId = undoHandler.selectedShapeId;\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    if (this.targetObject !== null) {\n      this.updateShape(this.selectedShapeId, this.newValue);\n      if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n    }\n\n    return true;\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {//   this.targetObject.fillColor = this.oldValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {//   this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {//   return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {//   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n  }\n\n} // export default class ChangeFillColorCommandObject extends CommandObject {\n//   constructor(undoHandler, oldColor, newColor, selectedObj) {\n//     super(undoHandler, true);\n//     this.targetObject = selectedObj;\n//     this.newValue = newColor;\n//     this.oldValue = oldColor\n//   }\n//   /* override to execute the action of this command.\n//    * pass in false for addToUndoStack if this is a command which is NOT\n//    * put on the undo stack, like Copy, or a change of selection or Save\n//    */\n//   execute() {\n//     if (this.targetObject !== null) {\n//       this.targetObject = selectedObj; // global variable for selected\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n//       selectedObj.fillColor = this.newValue; // actually change\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n//     }\n//   }\n//   /* override to undo the operation of this command\n//    */\n//   undo() {\n//     this.targetObject.fillColor = this.oldValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n//   /* override to redo the operation of this command, which means to\n//    * undo the undo. This should ONLY be called if the immediate\n//    * previous operation was an Undo of this command. Anything that\n//    * can be undone can be redone, so there is no need for a canRedo.\n//    */\n//   redo() {\n//     this.targetObject.fillColor = this.newValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n//   /* override to return true if this operation can be repeated in the\n//    * current context\n//    */\n//   canRepeat() {\n//     return selectedObj !== null;\n//   }\n//   /* override to execute the operation again, this time possibly on\n//    * a new object. Thus, this typically uses the same value but a new\n//    * selectedObject.\n//    */\n//   repeat() {\n//     if (selectedObj !== null) {\n//       this.targetObject = selectedObj; // get new selected obj\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       // no change to newValue since reusing the same color\n//       selectedObj.fillColor = this.newValue; // actually change\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n//     }\n//   }\n// }","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"names":["CommandObject","ChangeFillColorCommandObject","constructor","undoHandler","updateShape","shapeId","newData","shapesMap","state","targetShape","setState","console","log","oldValue","oldFillColor","newValue","currFillColor","targetObject","selectedShapeId","execute","addToUndoStack","registerExecution","undo","redo","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AAEA,eAAe,MAAMC,4BAAN,SAA2CD,aAA3C,CAAyD;AACpEE,EAAAA,WAAW,CAACC,WAAD,EAAc;AACvB,UAAMA,WAAN,EAAmB,IAAnB;;AADuB,SAwBzBC,WAxByB,GAwBX,CAACC,OAAD,EAAUC,OAAV,KAAsB;AAChC,UAAIC,SAAS,GAAG,EAAE,GAAG,KAAKC,KAAL,CAAWD;AAAhB,OAAhB;AACA,UAAIE,WAAW,GAAGF,SAAS,CAACF,OAAD,CAA3B;AACAE,MAAAA,SAAS,CAACF,OAAD,CAAT,GAAqB,EAAE,GAAGI,WAAL;AAAkB,WAAGH;AAArB,OAArB;AACA,WAAKI,QAAL,CAAc;AAAEH,QAAAA;AAAF,OAAd;AACD,KA7BsB;;AAEvBI,IAAAA,OAAO,CAACC,GAAR,CAAY,2CAAZ;AACA,SAAKC,QAAL,GAAgBV,WAAW,CAACW,YAA5B;AACAH,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKC,QAAjB;AACA,SAAKE,QAAL,GAAgBZ,WAAW,CAACa,aAA5B;AACAL,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKG,QAAjB;AACA,SAAKE,YAAL,GAAoBd,WAAW,CAACc,YAAhC;AACA,SAAKb,WAAL,GAAmBD,WAAW,CAACC,WAA/B;AACA,SAAKc,eAAL,GAAuBf,WAAW,CAACe,eAAnC;AACD;AAED;;;;;;AAIAC,EAAAA,OAAO,GAAG;AACR,QAAI,KAAKF,YAAL,KAAsB,IAA1B,EAAgC;AAC9B,WAAKb,WAAL,CAAiB,KAAKc,eAAtB,EAAuC,KAAKH,QAA5C;AACA,UAAI,KAAKK,cAAT,EAAyB,KAAKjB,WAAL,CAAiBkB,iBAAjB,CAAmC,IAAnC;AAC1B;;AACD,WAAO,IAAP;AACD;;AASD;;AAEAC,EAAAA,IAAI,GAAG,CACP;AACE;AACD;AAED;;;;;;;AAKAC,EAAAA,IAAI,GAAG,CACP;AACE;AACD;AAED;;;;;AAGAC,EAAAA,SAAS,GAAG,CACZ;AACC;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG,CACT;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACC;;AAvEmE,C,CA2ExE;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import CommandObject from \"./CommandObject\";\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n    constructor(undoHandler) {\n      super(undoHandler, true);\n      console.log(\"enter change fill color shape constructor\")\n      this.oldValue = undoHandler.oldFillColor;\n      console.log(this.oldValue)\n      this.newValue = undoHandler.currFillColor;\n      console.log(this.newValue)\n      this.targetObject = undoHandler.targetObject;\n      this.updateShape = undoHandler.updateShape;\n      this.selectedShapeId = undoHandler.selectedShapeId;\n    }\n  \n    /* override to execute the action of this command.\n     * pass in false for addToUndoStack if this is a command which is NOT\n     * put on the undo stack, like Copy, or a change of selection or Save\n     */\n    execute() {\n      if (this.targetObject !== null) {\n        this.updateShape(this.selectedShapeId, this.newValue)\n        if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n      }\n      return true;\n    }\n\n    updateShape = (shapeId, newData) => {\n        let shapesMap = { ...this.state.shapesMap };\n        let targetShape = shapesMap[shapeId];\n        shapesMap[shapeId] = { ...targetShape, ...newData };\n        this.setState({ shapesMap });\n      };\n  \n    /* override to undo the operation of this command\n     */\n    undo() {\n    //   this.targetObject.fillColor = this.oldValue;\n      // maybe also need to fix the palette to show this object's color?\n    }\n  \n    /* override to redo the operation of this command, which means to\n     * undo the undo. This should ONLY be called if the immediate\n     * previous operation was an Undo of this command. Anything that\n     * can be undone can be redone, so there is no need for a canRedo.\n     */\n    redo() {\n    //   this.targetObject.fillColor = this.newValue;\n      // maybe also need to fix the palette to show this object's color?\n    }\n  \n    /* override to return true if this operation can be repeated in the\n     * current context\n     */\n    canRepeat() {\n    //   return selectedObj !== null;\n    }\n  \n    /* override to execute the operation again, this time possibly on\n     * a new object. Thus, this typically uses the same value but a new\n     * selectedObject.\n     */\n    repeat() {\n    //   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n  \n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n    }\n  }\n\n\n// export default class ChangeFillColorCommandObject extends CommandObject {\n//   constructor(undoHandler, oldColor, newColor, selectedObj) {\n//     super(undoHandler, true);\n//     this.targetObject = selectedObj;\n//     this.newValue = newColor;\n//     this.oldValue = oldColor\n//   }\n\n//   /* override to execute the action of this command.\n//    * pass in false for addToUndoStack if this is a command which is NOT\n//    * put on the undo stack, like Copy, or a change of selection or Save\n//    */\n//   execute() {\n//     if (this.targetObject !== null) {\n//       this.targetObject = selectedObj; // global variable for selected\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n//       selectedObj.fillColor = this.newValue; // actually change\n\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n//     }\n//   }\n\n//   /* override to undo the operation of this command\n//    */\n//   undo() {\n//     this.targetObject.fillColor = this.oldValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n\n//   /* override to redo the operation of this command, which means to\n//    * undo the undo. This should ONLY be called if the immediate\n//    * previous operation was an Undo of this command. Anything that\n//    * can be undone can be redone, so there is no need for a canRedo.\n//    */\n//   redo() {\n//     this.targetObject.fillColor = this.newValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n\n//   /* override to return true if this operation can be repeated in the\n//    * current context\n//    */\n//   canRepeat() {\n//     return selectedObj !== null;\n//   }\n\n//   /* override to execute the operation again, this time possibly on\n//    * a new object. Thus, this typically uses the same value but a new\n//    * selectedObject.\n//    */\n//   repeat() {\n//     if (selectedObj !== null) {\n//       this.targetObject = selectedObj; // get new selected obj\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       // no change to newValue since reusing the same color\n//       selectedObj.fillColor = this.newValue; // actually change\n\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n//     }\n//   }\n// }"]},"metadata":{},"sourceType":"module"}