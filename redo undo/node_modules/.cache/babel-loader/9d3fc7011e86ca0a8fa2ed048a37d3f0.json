{"ast":null,"code":"import CommandObject from \"./CommandObject\"; // export default class ChangeFillColorCommandObject extends CommandObject {\n//   constructor(undoHandler, oldColor, newColor, selectedObj) {\n//     super(undoHandler, true);\n//     this.targetObject = selectedObj;\n//     this.newValue = newColor;\n//     this.oldValue = oldColor\n//   }\n//   /* override to execute the action of this command.\n//    * pass in false for addToUndoStack if this is a command which is NOT\n//    * put on the undo stack, like Copy, or a change of selection or Save\n//    */\n//   execute() {\n//     if (this.targetObject !== null) {\n//       this.targetObject = selectedObj; // global variable for selected\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n//       selectedObj.fillColor = this.newValue; // actually change\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n//     }\n//   }\n//   /* override to undo the operation of this command\n//    */\n//   undo() {\n//     this.targetObject.fillColor = this.oldValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n//   /* override to redo the operation of this command, which means to\n//    * undo the undo. This should ONLY be called if the immediate\n//    * previous operation was an Undo of this command. Anything that\n//    * can be undone can be redone, so there is no need for a canRedo.\n//    */\n//   redo() {\n//     this.targetObject.fillColor = this.newValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n//   /* override to return true if this operation can be repeated in the\n//    * current context\n//    */\n//   canRepeat() {\n//     return selectedObj !== null;\n//   }\n//   /* override to execute the operation again, this time possibly on\n//    * a new object. Thus, this typically uses the same value but a new\n//    * selectedObject.\n//    */\n//   repeat() {\n//     if (selectedObj !== null) {\n//       this.targetObject = selectedObj; // get new selected obj\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       // no change to newValue since reusing the same color\n//       selectedObj.fillColor = this.newValue; // actually change\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n//     }\n//   }\n// }","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"names":["CommandObject"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B,C,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import CommandObject from \"./CommandObject\";\n\n\n\n\n// export default class ChangeFillColorCommandObject extends CommandObject {\n//   constructor(undoHandler, oldColor, newColor, selectedObj) {\n//     super(undoHandler, true);\n//     this.targetObject = selectedObj;\n//     this.newValue = newColor;\n//     this.oldValue = oldColor\n//   }\n\n//   /* override to execute the action of this command.\n//    * pass in false for addToUndoStack if this is a command which is NOT\n//    * put on the undo stack, like Copy, or a change of selection or Save\n//    */\n//   execute() {\n//     if (this.targetObject !== null) {\n//       this.targetObject = selectedObj; // global variable for selected\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n//       selectedObj.fillColor = this.newValue; // actually change\n\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n//     }\n//   }\n\n//   /* override to undo the operation of this command\n//    */\n//   undo() {\n//     this.targetObject.fillColor = this.oldValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n\n//   /* override to redo the operation of this command, which means to\n//    * undo the undo. This should ONLY be called if the immediate\n//    * previous operation was an Undo of this command. Anything that\n//    * can be undone can be redone, so there is no need for a canRedo.\n//    */\n//   redo() {\n//     this.targetObject.fillColor = this.newValue;\n//     // maybe also need to fix the palette to show this object's color?\n//   }\n\n//   /* override to return true if this operation can be repeated in the\n//    * current context\n//    */\n//   canRepeat() {\n//     return selectedObj !== null;\n//   }\n\n//   /* override to execute the operation again, this time possibly on\n//    * a new object. Thus, this typically uses the same value but a new\n//    * selectedObject.\n//    */\n//   repeat() {\n//     if (selectedObj !== null) {\n//       this.targetObject = selectedObj; // get new selected obj\n//       this.oldValue = selectedObj.fillColor; // object's current color\n//       // no change to newValue since reusing the same color\n//       selectedObj.fillColor = this.newValue; // actually change\n\n//       // Note that this command object must be a NEW command object so it can be\n//       // registered to put it onto the stack\n//       if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n//     }\n//   }\n// }"]},"metadata":{},"sourceType":"module"}