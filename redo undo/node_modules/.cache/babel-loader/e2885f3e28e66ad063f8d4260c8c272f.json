{"ast":null,"code":"import CommandObject from \"./CommandObject\"; //let cmdObject = new CreateCommandObject(this.undoHandler,shapeData, this.state.shapes, this.state.shapesMap, id);\n\nexport default class DeleteCommandObject extends CommandObject {\n  constructor(undoHandler, shapesMap, selectedShapeId, shapes) {\n    super(undoHandler, true);\n    this.shapesMap = shapesMap;\n    this.setState = undoHandler.setState;\n    this.selectedShapeId = selectedShapeId;\n    this.shapes = shapes;\n    this.id = selectedShapeId;\n    this.setModeToSelect = undoHandler.setModeToSelect;\n    this.cleanRedoStack = undoHandler.cleanRedoStack; // this.grayRedo = undoHandler.grayRedo\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    let shapesMap = { ...this.shapesMap\n    };\n    shapesMap[this.id].visible = false;\n    this.setState({\n      shapesMap,\n      selectedShapeId: undefined\n    }); // this.cleanRedoStack()\n\n    return true;\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    let shapesMap = { ...this.shapesMap\n    };\n    shapesMap[this.id].visible = true;\n    this.setState({\n      shapesMap,\n      selectedShapeId: this.id\n    });\n    this.setState({\n      currFillColor: shapesMap[this.id].fillColor,\n      currBorderColor: shapesMap[this.id].borderColor,\n      currBorderWidth: shapesMap[id].borderWidth\n    });\n    this.setModeToSelect(); // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    let shapesMap = { ...this.shapesMap\n    };\n    shapesMap[this.id].visible = false;\n    this.setState({\n      shapesMap,\n      selectedShapeId: undefined\n    });\n    this.setModeToSelect(); // maybe also need to fix the palette to show this object's color?\n  }\n\n  getCurrentSelectedShapeId() {\n    return this.id;\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {//   return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {//   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n  }\n\n}","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/DeleteCommandObject.js"],"names":["CommandObject","DeleteCommandObject","constructor","undoHandler","shapesMap","selectedShapeId","shapes","setState","id","setModeToSelect","cleanRedoStack","execute","visible","undefined","undo","currFillColor","fillColor","currBorderColor","borderColor","currBorderWidth","borderWidth","redo","getCurrentSelectedShapeId","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B,C,CAEA;;AACA,eAAe,MAAMC,mBAAN,SAAkCD,aAAlC,CAAgD;AAC3DE,EAAAA,WAAW,CAACC,WAAD,EAAcC,SAAd,EAAyBC,eAAzB,EAA0CC,MAA1C,EAAkD;AAC3D,UAAMH,WAAN,EAAmB,IAAnB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKG,QAAL,GAAgBJ,WAAW,CAACI,QAA5B;AACA,SAAKF,eAAL,GAAuBA,eAAvB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKE,EAAL,GAAUH,eAAV;AACA,SAAKI,eAAL,GAAuBN,WAAW,CAACM,eAAnC;AACA,SAAKC,cAAL,GAAsBP,WAAW,CAACO,cAAlC,CAR2D,CAS3D;AACD;AAED;;;;;;AAKAC,EAAAA,OAAO,GAAG;AACR,QAAIP,SAAS,GAAG,EAAE,GAAG,KAAKA;AAAV,KAAhB;AACAA,IAAAA,SAAS,CAAC,KAAKI,EAAN,CAAT,CAAmBI,OAAnB,GAA6B,KAA7B;AACA,SAAKL,QAAL,CAAc;AAAEH,MAAAA,SAAF;AAAaC,MAAAA,eAAe,EAAEQ;AAA9B,KAAd,EAHQ,CAIR;;AACA,WAAO,IAAP;AACD;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACL,QAAIV,SAAS,GAAG,EAAE,GAAG,KAAKA;AAAV,KAAhB;AACAA,IAAAA,SAAS,CAAC,KAAKI,EAAN,CAAT,CAAmBI,OAAnB,GAA6B,IAA7B;AACA,SAAKL,QAAL,CAAc;AAAEH,MAAAA,SAAF;AAAaC,MAAAA,eAAe,EAAE,KAAKG;AAAnC,KAAd;AACA,SAAKD,QAAL,CAAc;AAACQ,MAAAA,aAAa,EAAEX,SAAS,CAAC,KAAKI,EAAN,CAAT,CAAmBQ,SAAnC;AAA8CC,MAAAA,eAAe,EAACb,SAAS,CAAC,KAAKI,EAAN,CAAT,CAAmBU,WAAjF;AAA8FC,MAAAA,eAAe,EAACf,SAAS,CAACI,EAAD,CAAT,CAAcY;AAA5H,KAAd;AACA,SAAKX,eAAL,GALK,CAOL;AACD;AAED;;;;;;;AAKAY,EAAAA,IAAI,GAAG;AACL,QAAIjB,SAAS,GAAG,EAAE,GAAG,KAAKA;AAAV,KAAhB;AACAA,IAAAA,SAAS,CAAC,KAAKI,EAAN,CAAT,CAAmBI,OAAnB,GAA6B,KAA7B;AACA,SAAKL,QAAL,CAAc;AAAEH,MAAAA,SAAF;AAAaC,MAAAA,eAAe,EAAEQ;AAA9B,KAAd;AACA,SAAKJ,eAAL,GAJK,CAML;AACD;;AAEDa,EAAAA,yBAAyB,GAAE;AACzB,WAAO,KAAKd,EAAZ;AACD;AAED;;;;;AAGAe,EAAAA,SAAS,GAAG,CACZ;AACC;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG,CACT;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACC;;AA9E0D","sourcesContent":["import CommandObject from \"./CommandObject\";\n\n//let cmdObject = new CreateCommandObject(this.undoHandler,shapeData, this.state.shapes, this.state.shapesMap, id);\nexport default class DeleteCommandObject extends CommandObject {\n    constructor(undoHandler, shapesMap, selectedShapeId, shapes) {\n      super(undoHandler, true);\n      this.shapesMap = shapesMap\n      this.setState = undoHandler.setState\n      this.selectedShapeId = selectedShapeId\n      this.shapes = shapes\n      this.id = selectedShapeId\n      this.setModeToSelect = undoHandler.setModeToSelect\n      this.cleanRedoStack = undoHandler.cleanRedoStack\n      // this.grayRedo = undoHandler.grayRedo\n    }\n\n    /* override to execute the action of this command.\n     * pass in false for addToUndoStack if this is a command which is NOT\n     * put on the undo stack, like Copy, or a change of selection or Save\n     */\n    \n    execute() {\n      let shapesMap = { ...this.shapesMap };\n      shapesMap[this.id].visible = false;\n      this.setState({ shapesMap, selectedShapeId: undefined });\n      // this.cleanRedoStack()\n      return true\n    }\n  \n    /* override to undo the operation of this command\n     */\n    undo() {\n      let shapesMap = { ...this.shapesMap };\n      shapesMap[this.id].visible = true;\n      this.setState({ shapesMap, selectedShapeId: this.id });\n      this.setState({currFillColor: shapesMap[this.id].fillColor, currBorderColor:shapesMap[this.id].borderColor, currBorderWidth:shapesMap[id].borderWidth})\n      this.setModeToSelect()\n\n      // maybe also need to fix the palette to show this object's color?\n    }\n  \n    /* override to redo the operation of this command, which means to\n     * undo the undo. This should ONLY be called if the immediate\n     * previous operation was an Undo of this command. Anything that\n     * can be undone can be redone, so there is no need for a canRedo.\n     */\n    redo() {\n      let shapesMap = { ...this.shapesMap };      \n      shapesMap[this.id].visible = false;\n      this.setState({ shapesMap, selectedShapeId: undefined }); \n      this.setModeToSelect()\n      \n      // maybe also need to fix the palette to show this object's color?\n    }\n\n    getCurrentSelectedShapeId(){\n      return this.id\n    }\n  \n    /* override to return true if this operation can be repeated in the\n     * current context\n     */\n    canRepeat() {\n    //   return selectedObj !== null;\n    }\n  \n    /* override to execute the operation again, this time possibly on\n     * a new object. Thus, this typically uses the same value but a new\n     * selectedObject.\n     */\n    repeat() {\n    //   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n  \n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n    }\n  }\n\n\n\n"]},"metadata":{},"sourceType":"module"}