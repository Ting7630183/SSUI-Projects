{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, oldColor, fillColor, selectedShapeId) {\n    super(undoHandler, true);\n    this.oldValue = oldColor;\n    this.newValue = fillColor;\n    this.selectedShapeId = selectedShapeId;\n    this.updateShape = undoHandler.updateShape;\n    this.setState = undoHandler.setState;\n    this.setModeToSelect = undoHandler.setModeToSelect;\n    this.cleanRedoStack = undoHandler.cleanRedoStack;\n    this.grayRedo = undoHandler.grayRedo;\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    var fillColor = this.newValue;\n    this.updateShape(this.selectedShapeId, {\n      fillColor\n    });\n    this.setState({\n      currFillColor: fillColor\n    });\n    this.cleanRedoStack();\n    this.gr;\n    return true;\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    var fillColor = this.oldValue;\n    this.updateShape(this.selectedShapeId, {\n      fillColor\n    });\n    this.setState({\n      currFillColor: fillColor\n    });\n    this.setModeToSelect();\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    var fillColor = this.newValue;\n    this.updateShape(this.selectedShapeId, {\n      fillColor\n    });\n    this.setState({\n      currFillColor: fillColor\n    });\n    this.setModeToSelect();\n  }\n\n  getCurrentSelectedShapeId() {\n    return this.selectedShapeId;\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {//   return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {//   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n  }\n\n}","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"names":["CommandObject","ChangeFillColorCommandObject","constructor","undoHandler","oldColor","fillColor","selectedShapeId","oldValue","newValue","updateShape","setState","setModeToSelect","cleanRedoStack","grayRedo","execute","currFillColor","gr","undo","redo","getCurrentSelectedShapeId","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AAEA,eAAe,MAAMC,4BAAN,SAA2CD,aAA3C,CAAyD;AACpEE,EAAAA,WAAW,CAACC,WAAD,EAAcC,QAAd,EAAwBC,SAAxB,EAAmCC,eAAnC,EAAoD;AAC7D,UAAMH,WAAN,EAAmB,IAAnB;AACA,SAAKI,QAAL,GAAgBH,QAAhB;AACA,SAAKI,QAAL,GAAgBH,SAAhB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKG,WAAL,GAAmBN,WAAW,CAACM,WAA/B;AACA,SAAKC,QAAL,GAAgBP,WAAW,CAACO,QAA5B;AACA,SAAKC,eAAL,GAAuBR,WAAW,CAACQ,eAAnC;AACA,SAAKC,cAAL,GAAsBT,WAAW,CAACS,cAAlC;AACA,SAAKC,QAAL,GAAgBV,WAAW,CAACU,QAA5B;AACD;AAED;;;;;;AAIAC,EAAAA,OAAO,GAAG;AACN,QAAIT,SAAS,GAAG,KAAKG,QAArB;AACA,SAAKC,WAAL,CAAiB,KAAKH,eAAtB,EAAuC;AAACD,MAAAA;AAAD,KAAvC;AACA,SAAKK,QAAL,CAAc;AAAEK,MAAAA,aAAa,EAAEV;AAAjB,KAAd;AACA,SAAKO,cAAL;AACA,SAAKI,EAAL;AACA,WAAO,IAAP;AACH;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACH,QAAIZ,SAAS,GAAG,KAAKE,QAArB;AACA,SAAKE,WAAL,CAAiB,KAAKH,eAAtB,EAAuC;AAACD,MAAAA;AAAD,KAAvC;AACA,SAAKK,QAAL,CAAc;AAAEK,MAAAA,aAAa,EAAEV;AAAjB,KAAd;AACA,SAAKM,eAAL;AACH;AAED;;;;;;;AAKAO,EAAAA,IAAI,GAAG;AACH,QAAIb,SAAS,GAAG,KAAKG,QAArB;AACA,SAAKC,WAAL,CAAiB,KAAKH,eAAtB,EAAuC;AAACD,MAAAA;AAAD,KAAvC;AACA,SAAKK,QAAL,CAAc;AAAEK,MAAAA,aAAa,EAAEV;AAAjB,KAAd;AACA,SAAKM,eAAL;AACH;;AAEDQ,EAAAA,yBAAyB,GAAE;AACzB,WAAO,KAAKb,eAAZ;AACD;AAED;;;;;AAGAc,EAAAA,SAAS,GAAG,CACZ;AACC;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG,CACT;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACC;;AAzEmE","sourcesContent":["import CommandObject from \"./CommandObject\";\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n    constructor(undoHandler, oldColor, fillColor, selectedShapeId) {\n      super(undoHandler, true);\n      this.oldValue = oldColor\n      this.newValue = fillColor\n      this.selectedShapeId = selectedShapeId\n      this.updateShape = undoHandler.updateShape;\n      this.setState = undoHandler.setState\n      this.setModeToSelect = undoHandler.setModeToSelect\n      this.cleanRedoStack = undoHandler.cleanRedoStack\n      this.grayRedo = undoHandler.grayRedo\n    }\n  \n    /* override to execute the action of this command.\n     * pass in false for addToUndoStack if this is a command which is NOT\n     * put on the undo stack, like Copy, or a change of selection or Save\n     */\n    execute() {\n        var fillColor = this.newValue\n        this.updateShape(this.selectedShapeId, {fillColor})\n        this.setState({ currFillColor: fillColor })\n        this.cleanRedoStack()\n        this.gr\n        return true; \n    }\n  \n    /* override to undo the operation of this command\n     */\n    undo() {\n        var fillColor = this.oldValue\n        this.updateShape(this.selectedShapeId, {fillColor})\n        this.setState({ currFillColor: fillColor })   \n        this.setModeToSelect()\n    }\n  \n    /* override to redo the operation of this command, which means to\n     * undo the undo. This should ONLY be called if the immediate\n     * previous operation was an Undo of this command. Anything that\n     * can be undone can be redone, so there is no need for a canRedo.\n     */\n    redo() {\n        var fillColor = this.newValue\n        this.updateShape(this.selectedShapeId, {fillColor})\n        this.setState({ currFillColor: fillColor })\n        this.setModeToSelect()\n    }\n\n    getCurrentSelectedShapeId(){\n      return this.selectedShapeId\n    }\n  \n    /* override to return true if this operation can be repeated in the\n     * current context\n     */\n    canRepeat() {\n    //   return selectedObj !== null;\n    }\n  \n    /* override to execute the operation again, this time possibly on\n     * a new object. Thus, this typically uses the same value but a new\n     * selectedObject.\n     */\n    repeat() {\n    //   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n  \n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n    }\n  }\n\n\n"]},"metadata":{},"sourceType":"module"}