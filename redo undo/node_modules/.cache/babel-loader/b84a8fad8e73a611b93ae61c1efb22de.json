{"ast":null,"code":"import CommandObject from \"./CommandObject\"; //let cmdObject = new CreateCommandObject(this.undoHandler,shapeData, this.state.shapes, this.state.shapesMap, id);\n\nexport default class CreateCommandObject extends CommandObject {\n  constructor(undoHandler, shapeData, shapes, shapesMap, id, selectedShapeId, setStateHelper) {\n    super(undoHandler, true);\n    this.shapeData = shapeData;\n    this.shapes = shapes;\n    this.shapesMap = shapesMap;\n    this.id = id;\n    this.setState = undoHandler.setState;\n    this.selectedShapeId = selectedShapeId;\n    this.setStateHelper = setStateHelper;\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  // let shapes = [...this.state.shapes];\n  // let shapesMap = { ...this.state.shapesMap };\n  // shapesMap[id] = {\n  //   ...shapeData,\n  //   id,\n  // };\n  // shapes.push(id);\n  // this.setState({ shapes, shapesMap, selectedShapeId: id });\n\n\n  execute() {\n    let shapes = [...this.shapes];\n    let shapesMap = { ...this.shapesMap\n    };\n    console.log(shapesMap);\n    let id = this.id;\n    console.log(id);\n    let shapeData = this.shapeData;\n    console.log(shapeData);\n    console.log(this.setState); // let selectedShapeId = this.selectedShapeId\n    // let setState = this.setState\n\n    shapesMap[id] = { ...shapeData,\n      id\n    };\n    shapes.push(id);\n    console.log(shapes);\n    this.setState({\n      shapes,\n      shapesMap,\n      selectedShapeId: id\n    });\n    return true;\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    var fillColor = this.oldValue;\n    this.updateShape(this.selectedShapeId, {\n      fillColor\n    }); // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    var fillColor = this.newValue;\n    this.updateShape(this.selectedShapeId, {\n      fillColor\n    }); // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {//   return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {//   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n  }\n\n}","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/CreateCommandObject.js"],"names":["CommandObject","CreateCommandObject","constructor","undoHandler","shapeData","shapes","shapesMap","id","selectedShapeId","setStateHelper","setState","execute","console","log","push","undo","fillColor","oldValue","updateShape","redo","newValue","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B,C,CAEA;;AACA,eAAe,MAAMC,mBAAN,SAAkCD,aAAlC,CAAgD;AAC3DE,EAAAA,WAAW,CAACC,WAAD,EAAcC,SAAd,EAAyBC,MAAzB,EAAiCC,SAAjC,EAA4CC,EAA5C,EAAgDC,eAAhD,EAAiEC,cAAjE,EAAiF;AAC1F,UAAMN,WAAN,EAAmB,IAAnB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKG,QAAL,GAAgBP,WAAW,CAACO,QAA5B;AACA,SAAKF,eAAL,GAAuBA,eAAvB;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACD;AAED;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAE,EAAAA,OAAO,GAAG;AACR,QAAIN,MAAM,GAAG,CAAC,GAAG,KAAKA,MAAT,CAAb;AAEA,QAAIC,SAAS,GAAG,EAAE,GAAG,KAAKA;AAAV,KAAhB;AACAM,IAAAA,OAAO,CAACC,GAAR,CAAYP,SAAZ;AACA,QAAIC,EAAE,GAAG,KAAKA,EAAd;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAYN,EAAZ;AACA,QAAIH,SAAS,GAAG,KAAKA,SAArB;AACAQ,IAAAA,OAAO,CAACC,GAAR,CAAYT,SAAZ;AACAQ,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKH,QAAjB,EATQ,CAUR;AACA;;AACAJ,IAAAA,SAAS,CAACC,EAAD,CAAT,GAAgB,EACZ,GAAGH,SADS;AAEZG,MAAAA;AAFY,KAAhB;AAIAF,IAAAA,MAAM,CAACS,IAAP,CAAYP,EAAZ;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAYR,MAAZ;AACA,SAAKK,QAAL,CAAc;AAAEL,MAAAA,MAAF;AAAUC,MAAAA,SAAV;AAAqBE,MAAAA,eAAe,EAAED;AAAtC,KAAd;AACA,WAAO,IAAP;AACD;AAED;;;;AAEAQ,EAAAA,IAAI,GAAG;AACH,QAAIC,SAAS,GAAG,KAAKC,QAArB;AACA,SAAKC,WAAL,CAAiB,KAAKV,eAAtB,EAAuC;AAACQ,MAAAA;AAAD,KAAvC,EAFG,CAIL;AACD;AAED;;;;;;;AAKAG,EAAAA,IAAI,GAAG;AACH,QAAIH,SAAS,GAAG,KAAKI,QAArB;AACA,SAAKF,WAAL,CAAiB,KAAKV,eAAtB,EAAuC;AAACQ,MAAAA;AAAD,KAAvC,EAFG,CAGL;AACD;AAED;;;;;AAGAK,EAAAA,SAAS,GAAG,CACZ;AACC;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG,CACT;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACC;;AAzF0D","sourcesContent":["import CommandObject from \"./CommandObject\";\n\n//let cmdObject = new CreateCommandObject(this.undoHandler,shapeData, this.state.shapes, this.state.shapesMap, id);\nexport default class CreateCommandObject extends CommandObject {\n    constructor(undoHandler, shapeData, shapes, shapesMap, id, selectedShapeId, setStateHelper) {\n      super(undoHandler, true);\n      this.shapeData = shapeData\n      this.shapes = shapes\n      this.shapesMap = shapesMap\n      this.id = id\n      this.setState = undoHandler.setState\n      this.selectedShapeId = selectedShapeId\n      this.setStateHelper = setStateHelper\n    }\n  \n    /* override to execute the action of this command.\n     * pass in false for addToUndoStack if this is a command which is NOT\n     * put on the undo stack, like Copy, or a change of selection or Save\n     */\n    // let shapes = [...this.state.shapes];\n    // let shapesMap = { ...this.state.shapesMap };\n    \n    // shapesMap[id] = {\n    //   ...shapeData,\n    //   id,\n    // };\n    // shapes.push(id);\n    // this.setState({ shapes, shapesMap, selectedShapeId: id });\n    execute() {\n      let shapes = [...this.shapes];\n      \n      let shapesMap = { ...this.shapesMap };\n      console.log(shapesMap)\n      let id = this.id\n      console.log(id)\n      let shapeData = this.shapeData\n      console.log(shapeData)\n      console.log(this.setState)\n      // let selectedShapeId = this.selectedShapeId\n      // let setState = this.setState\n      shapesMap[id] = {\n          ...shapeData,\n          id,\n      };\n      shapes.push(id);\n      console.log(shapes)\n      this.setState({ shapes, shapesMap, selectedShapeId: id });\n      return true; \n    }\n  \n    /* override to undo the operation of this command\n     */\n    undo() {\n        var fillColor = this.oldValue\n        this.updateShape(this.selectedShapeId, {fillColor})\n        \n      // maybe also need to fix the palette to show this object's color?\n    }\n  \n    /* override to redo the operation of this command, which means to\n     * undo the undo. This should ONLY be called if the immediate\n     * previous operation was an Undo of this command. Anything that\n     * can be undone can be redone, so there is no need for a canRedo.\n     */\n    redo() {\n        var fillColor = this.newValue\n        this.updateShape(this.selectedShapeId, {fillColor})\n      // maybe also need to fix the palette to show this object's color?\n    }\n  \n    /* override to return true if this operation can be repeated in the\n     * current context\n     */\n    canRepeat() {\n    //   return selectedObj !== null;\n    }\n  \n    /* override to execute the operation again, this time possibly on\n     * a new object. Thus, this typically uses the same value but a new\n     * selectedObject.\n     */\n    repeat() {\n    //   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n  \n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n    }\n  }\n\n\n\n"]},"metadata":{},"sourceType":"module"}