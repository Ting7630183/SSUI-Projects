{"ast":null,"code":"import CommandObject from \"./CommandObject\"; // import App from \"../../App\";\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(App, oldColor, fillColor) {\n    console.log(App); // console.log(\"create a new object\")\n\n    super(App.undoHandler, true);\n    this.targetObject = selectedObj;\n    this.newValue = fillColor;\n    this.oldValue = oldColor; // this.selectedShapeId = selectedShapeId\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    if (this.targetObject !== null) {\n      console.log(this.targetObject);\n      console.log(this.oldValue);\n      console.log(this.newValue); // this.targetObject = this.selectedObj; // global variable for selected\n      // this.oldValue = this.selectedObj.fillColor; // object's current color\n      // // this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n      // this.newValue = this.selectedObj.currentColor; // get the color widget's current color\n      // this.targetObject.fillColor = this.newValue; // actually change\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n\n      console.log(\"add to stack\");\n      if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n    }\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    console.log(\"enter undo in the change color class\"); // console.log(this.oldValue)\n    // console.log(this.targetObject)\n    // App.updateShape(this.selectedShapeId, this.newValue)\n    // this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {// this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {// return this.selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {\n    if (this.selectedObj !== null) {\n      this.targetObject = this.selectedObj; // get new selected obj\n\n      this.oldValue = this.selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n\n      this.selectedObj.fillColor = this.newValue; // actually change\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/christy/Desktop/Fall2022/SSUI/Homework/hw5-Ting7630183/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"names":["CommandObject","ChangeFillColorCommandObject","constructor","App","oldColor","fillColor","console","log","undoHandler","targetObject","selectedObj","newValue","oldValue","execute","addToUndoStack","registerExecution","undo","redo","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B,C,CACA;;AAEA,eAAe,MAAMC,4BAAN,SAA2CD,aAA3C,CAAyD;AACtEE,EAAAA,WAAW,CAACC,GAAD,EAAMC,QAAN,EAAgBC,SAAhB,EAA2B;AACpCC,IAAAA,OAAO,CAACC,GAAR,CAAYJ,GAAZ,EADoC,CAEpC;;AACA,UAAMA,GAAG,CAACK,WAAV,EAAuB,IAAvB;AACA,SAAKC,YAAL,GAAoBC,WAApB;AACA,SAAKC,QAAL,GAAgBN,SAAhB;AACA,SAAKO,QAAL,GAAgBR,QAAhB,CANoC,CAOpC;AACD;AAED;;;;;;AAIAS,EAAAA,OAAO,GAAG;AACR,QAAI,KAAKJ,YAAL,KAAsB,IAA1B,EAAgC;AAC9BH,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKE,YAAjB;AACAH,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKK,QAAjB;AACAN,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKI,QAAjB,EAH8B,CAI9B;AACA;AACA;AACA;AACA;AAEA;AACA;;AACAL,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACA,UAAI,KAAKO,cAAT,EAAyB,KAAKN,WAAL,CAAiBO,iBAAjB,CAAmC,IAAnC;AAC1B;AACF;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACLV,IAAAA,OAAO,CAACC,GAAR,CAAY,sCAAZ,EADK,CAEL;AACA;AACA;AACA;AACA;AACD;AAED;;;;;;;AAKAU,EAAAA,IAAI,GAAG,CACL;AACA;AACD;AAED;;;;;AAGAC,EAAAA,SAAS,GAAG,CACV;AACD;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKT,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKD,YAAL,GAAoB,KAAKC,WAAzB,CAD6B,CACS;;AACtC,WAAKE,QAAL,GAAgB,KAAKF,WAAL,CAAiBL,SAAjC,CAF6B,CAEe;AAC5C;;AACA,WAAKK,WAAL,CAAiBL,SAAjB,GAA6B,KAAKM,QAAlC,CAJ6B,CAIe;AAE5C;AACA;;AACA,UAAI,KAAKG,cAAT,EAAyB,KAAKN,WAAL,CAAiBO,iBAAjB,CAAmC,EAAE,GAAG;AAAL,OAAnC;AAC1B;AACF;;AA5EqE","sourcesContent":["import CommandObject from \"./CommandObject\";\n// import App from \"../../App\";\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(App, oldColor, fillColor) {\n    console.log(App)\n    // console.log(\"create a new object\")\n    super(App.undoHandler, true);\n    this.targetObject = selectedObj;\n    this.newValue = fillColor;\n    this.oldValue = oldColor\n    // this.selectedShapeId = selectedShapeId\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    if (this.targetObject !== null) {\n      console.log(this.targetObject)\n      console.log(this.oldValue)\n      console.log(this.newValue)\n      // this.targetObject = this.selectedObj; // global variable for selected\n      // this.oldValue = this.selectedObj.fillColor; // object's current color\n      // // this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n      // this.newValue = this.selectedObj.currentColor; // get the color widget's current color\n      // this.targetObject.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      console.log(\"add to stack\")\n      if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n    }\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    console.log(\"enter undo in the change color class\")\n    // console.log(this.oldValue)\n    // console.log(this.targetObject)\n    // App.updateShape(this.selectedShapeId, this.newValue)\n    // this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    // this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    // return this.selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    if (this.selectedObj !== null) {\n      this.targetObject = this.selectedObj; // get new selected obj\n      this.oldValue = this.selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n      this.selectedObj.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}